//! `SeaORM` Entity, @generated by sea-orm-codegen 1.1.5

use axum::{response::IntoResponse, Json};
use sea_orm::{entity::prelude::*, QueryOrder, QuerySelect};
use serde::{Deserialize, Serialize};
use utoipa::ToSchema;

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Serialize, Deserialize, ToSchema)]
#[sea_orm(table_name = "weathers")]
pub struct Model {
    #[sea_orm(primary_key, auto_increment = true, unique)]
    pub id: u32,
    #[sea_orm(unique)]
    #[schema(value_type = String, example = "2025-02-22T14:30:00Z")]
    pub record_time: DateTime,
    pub description: Option<String>,
    #[sea_orm(column_type = "Float")]
    pub temp: f32,
    #[sea_orm(column_type = "Float", nullable)]
    pub temp_max: Option<f32>,
    #[sea_orm(column_type = "Float", nullable)]
    pub temp_min: Option<f32>,
    #[sea_orm(column_type = "Float", nullable)]
    pub humidity: Option<f32>,
    #[sea_orm(column_type = "Float", nullable)]
    pub wind: Option<f32>,
    #[sea_orm(column_type = "Float", nullable)]
    pub wind_deg: Option<f32>,
    pub cloud: Option<i32>,
    pub city: Option<String>,
    #[schema(value_type = String, example = "12:34:56")]
    pub sunrise: Option<Time>,
    #[schema(value_type = String, example = "12:34:56")]
    pub sunset: Option<Time>,
    #[schema(value_type = String, example = "2025-02-22T14:30:00Z")]
    pub created_at: DateTime,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {}

impl ActiveModelBehavior for ActiveModel {}

#[derive(Debug, Serialize)]
pub struct ChartDataPoint {
    pub time: String,
    pub temperature: f32,
    pub humidity: Option<f32>,
}

impl Entity {
    pub async fn get_latest_record(db: &DatabaseConnection) -> impl IntoResponse {
        let record = Entity::find().order_by_desc(Column::CreatedAt).one(db).await;
        match record {
            Ok(Some(record)) => Json(record).into_response(),
            Ok(None) => "No records found".into_response(),
            Err(e) => {
                (axum::http::StatusCode::INTERNAL_SERVER_ERROR, e.to_string()).into_response()
            }
        }
    }

    pub async fn get_last_n_temp_records(
        db: &DatabaseConnection,
        n: u64,
        city: String,
    ) -> Result<Json<Vec<ChartDataPoint>>, DbErr> {
        let total_count = Entity::find().count(db).await?;
        let safe_limit = std::cmp::min(n * 100, total_count as u64);

        let records = Entity::find()
            .select_only()
            .column(Column::RecordTime)
            .column(Column::Temp)
            .column(Column::Humidity)
            .filter(Column::City.eq(Some(city)))
            .order_by_desc(Column::RecordTime)
            .limit(safe_limit)
            .into_tuple::<(DateTime, f32, Option<f32>)>()
            .all(db)
            .await?;

        // Filter records to ensure 1+ hour between them
        let mut filtered_records = Vec::new();
        let mut last_time: Option<DateTime> = None;

        for record in records {
            if let Some(prev_time) = last_time {
                let diff = prev_time.signed_duration_since(record.0);
                if diff.num_minutes() >= 60 {
                    filtered_records.push(ChartDataPoint {
                        time: record.0.format("%H:%M").to_string(),
                        temperature: record.1,
                        humidity: record.2,
                    });
                    last_time = Some(record.0);
                }
            } else {
                filtered_records.push(ChartDataPoint {
                    time: record.0.format("%H:%M").to_string(),
                    temperature: record.1,
                    humidity: record.2,
                });
                last_time = Some(record.0);
            }

            if filtered_records.len() >= n as usize {
                break;
            }
        }

        filtered_records.reverse();
        Ok(Json(filtered_records))
    }
}
